# os_kollok2_15-04-25
# Касяник Екатерина 11 групппа 2 курс 
# Вариант 2
# Классические поведенческие шаблоны проектирования

## 1. Шаблон **Состояние (State)**
**Проблема:**  
Объект должен менять своё поведение в зависимости от внутреннего состояния. Прямая проверка состояния через условные операторы приводит к нарушению **инкапсуляции** и усложнению поддержки.

**Решение:**  
- Инкапсуляция состояний в отдельные классы, реализующие общий интерфейс.  
- Контекст делегирует работу текущему объекту-состоянию.  
- Соответствует принципу **«разделяй и властвуй»** — каждое состояние ортогонально другим.  

**Примеры:**  
1. **Документ (Черновик/Опубликован/Архив):**  
   - Состояния `Draft`, `Published`, `Archived` реализуют метод `publish()`.  
   - Контекст `Document` переключает состояния, изменяя поведение без условных проверок.  

2. **Торговый автомат:**  
   - Состояния `NoCoin`, `HasCoin`, `Sold` управляют логикой выдачи товара.  

3. **Сетевые соединения (TCP):**  
   - Состояния `Established`, `Listen`, `Closed` обрабатывают запросы.  

**Многопоточность:**  
Требуется синхронизация изменения состояния (например, `AtomicReference` в Java).  

---

## 2. Шаблон **Посредник (Mediator)**
**Проблема:**  
Множество объектов взаимодействуют друг с другом напрямую, создавая **сильные耦合** и усложняя модификацию системы.  

**Решение:**  
- Централизация взаимодействия через объект-посредник.  
- Компоненты общаются только с посредником, соблюдая **инкапсуляцию**.  
- Ортогональность: компоненты не знают о существовании друг друга.  

**Примеры:**  
1. **Чат-комната:**  
   - `User` отправляет сообщения через `ChatMediator`, который рассылает их другим участникам.  

2. **Управление авиарейсами:**  
   - `AirTrafficControl` координирует взлёт/посадку самолётов (`Flight`).  

3. **GUI-библиотеки (например, QT):**  
   - `QDialog` выступает посредником между кнопками (`QPushButton`) и полями ввода.  

**Многопоточность:**  
Посредник может стать узким местом — требуется thread-safe реализация (например, мьютексы).  

---

## 3. Шаблон **Наблюдатель (Observer)**
**Проблема:**  
Объектам необходимо реагировать на изменения другого объекта без жёсткой связки.  

**Решение:**  
- Издатель (`Subject`) уведомляет подписчиков (`Observers`) через событийный механизм.  
- **Инкапсуляция:** Издатель не знает деталей реализации наблюдателей.  
- Ортогональность: наблюдатели могут быть добавлены/удалены динамически.  

**Примеры:**  
1. **QT (Сигналы и слоты):**  
   - `QButton` испускает сигнал `clicked()`, который связывается со слотом `onClick()` другого объекта.  

2. **Погодная станция:**  
   - `WeatherData` рассылает обновления `TemperatureDisplay` и `ForecastDisplay`.  

3. **React/Redux:**  
   - Компоненты подписываются на изменения хранилища (store).  

**Многопоточность:**  
Асинхронные уведомления (например, через `EventBus` с очередями сообщений).  

---

# Дизайн ПО и многопоточность

## **Что такое дизайн ПО?**  
Дизайн ПО — это процесс создания структуры системы, включающий:  
- **Разделение ответственности** (разделяй и властвуй).  
- **Инкапсуляцию** деталей реализации.  
- **Ортогональность** компонентов для минимизации зависимостей.  

## **Влияние многопоточности**  
1. **Конкурентность:**  
   - Шаблоны (например, Observer) требуют thread-safe реализации (volatile, мьютексы).  
2. **Производительность:**  
   - Посредник (Mediator) может стать bottleneck.  
3. **Детерминизм:**  
   - Состояние (State) должно атомарно переключаться.  
4. **Асинхронность:**  
   - Наблюдатель в GUI (QT) использует event-loop для потокобезопасности.  

**Вывод:**  
Многопоточность усложняет дизайн, требуя явного управления состоянием, синхронизации и минимизации блокировок.  
